# Elixir Design Session - 2025-12-27 (Session 3)

## Session Context
- **Prior sessions**:
  - `2025-12-24-0639.md` (Dimensions 1-13)
  - `2025-12-25-0409.md` (Dimensions 14-17, gap resolution)
  - `2025-12-27-0639.md` (Dimensions 20-21, critique evaluation)
  - `2025-12-27-1100.md` (Dimension 20-21 gap resolution, FSP v1.0)
- **Consolidated design**: `docs/elixir-design.md` (21 dimensions documented)
- **Research backlog**: `docs/TODO-ANALYSIS.md` (5 research items)
- **Analysis artifacts**:
  - `reports/synthesis/comparison-matrix.md`
  - `reports/synthesis/antipatterns.md`
  - `reports/synthesis/reference-architecture.md`
- **Session goal**: TBD

---

## Session Resume Summary

### Completed Dimensions (21)

| # | Dimension | Decision |
|---|-----------|----------|
| 1 | Core Architecture | Deep Agents via GenServer + Task |
| 2 | Process Structure | SessionController GenServer + Task.async for steps |
| 3 | State Model | PostgreSQL + Redis with Ecto embedded schemas |
| 4 | Message Protocol | Lightweight reference structs (session_id, plan_id, step_index) |
| 5 | ETS Layout | 5 tables: :sessions, :messages, :context, :cache, :sub_agent_contexts |
| 6 | Clustering | Node affinity + ex_hash_ring + write-behind persistence |
| 7 | Tool System | Ecto schemas, introspection, ToolError, sandbox_mode callback |
| 8 | LLM Integration | Req + Behaviour adapters, PubSub streaming, Hammer, :fuse |
| 9 | Memory/Context | Token budget + eviction, pgvector + pg_bm25, tiktoken NIF |
| 10 | Multi-Agent | SessionController orchestrates sub-agents; hub-and-spoke |
| 11 | Observability | Telemetry + OpenTelemetry, step-level granularity |
| 12 | Error Handling | Feed errors to LLM, checkpoint recovery, max iterations |
| 13 | Interrupts/Breakpoints | Hybrid (step-level + runtime registry), timeout with default |
| 14 | Human-in-the-Loop | Step type + tool, PubSub → Phoenix Channel → WebSocket |
| 15 | Time Travel Debugging | Hybrid snapshots + events, L1 view-only inspection |
| 16 | Sub-Agent Architecture | Task-based with ETS context; ephemeral processes, persistent context |
| 17 | Artifact/Workspace Memory | S3-compatible storage with behaviour abstraction |
| 18 | System Prompts | EEx templates in priv/prompts/; directory override |
| 19 | Context Handoff | Hybrid extraction: code facts + LLM interpretation |
| 20 | Hierarchical Memory | 50/30/20 split: recent verbatim, historical summary, semantic retrieval |
| 21 | Sandbox Interface | Behaviour + WebSocket protocol for external code execution sandbox |

### Critique Items Resolved

| Recommendation | Status | Notes |
|----------------|--------|-------|
| BSP Supersteps | Skipped | GenServer provides ordering; solves non-problem |
| 50/30/20 Memory | Adopted | Dimension 20 |
| Tool Sandboxing | Adopted (interface) | Dimension 21 + FSP v1.0 |
| Error-as-Data | Adopted | ToolError schema refinement |
| Tagged IDs | Skipped | Marginal benefit; Ecto validates at boundaries |
| Agno Taxonomy | Deferred | Research task in TODO-ANALYSIS.md |

### New Artifacts from Prior Sessions

1. **Fathom Sandbox Protocol v1.0** (`docs/fathom-sandbox-protocol.md`)
2. **Context struct** with tier provenance
3. **Accumulator module** for sandbox protocol
4. **ToolError** complete schema with format_for_llm

### Research Items Pending

1. Tiktoken Elixir bindings (Medium priority)
2. Context compaction alternatives (Medium priority)
3. LiteLLM provider patterns (Low priority)
4. Agno event taxonomy (Low priority)
5. OpenTelemetry GenAI conventions (Low priority)

---

## Session Content

### Evaluation: elixir_enhancements.md

Analyzing five enhancement proposals against our current design. Each is evaluated for merit, fit with existing decisions, and implementation impact.

---

## Enhancement 1: Scatter-Gather Parallel Tool Execution

**Proposal:** Replace `pending_task: reference() | nil` with `pending_tasks: %{reference() => task_metadata()}` to enable parallel tool execution.

**Current design:** Session state has `pending_task: reference() | nil` (single active task).

**Evaluation:**

| Aspect | Assessment |
|--------|------------|
| Merit | High. LLMs can request multiple tool calls in one response. Serial execution is artificial bottleneck. |
| BEAM fit | Excellent. This is exactly what Task.async_stream / Task.await_many are built for. |
| Complexity | Low. Change from single ref to Map of refs. |
| Risk | Low. Easy to implement incrementally. |

**Recommendation:** **ADOPT**

This is a clear win. OpenAI's parallel tool calling is standard, and serializing what the LLM intended to be parallel is wasteful.

**Design change:**
```elixir
# Session state change
pending_tasks: %{reference() => %{tool_call_id: String.t(), tool_module: module(), started_at: DateTime.t()}}

# StepExecutor change
def execute_tools(tool_calls, context) do
  tasks =
    Enum.map(tool_calls, fn call ->
      {call.id, Task.Supervisor.async_nolink(ToolTaskSupervisor, fn ->
        Executor.execute(call.tool_module, call.params, context)
      end)}
    end)

  # Await all with timeout
  Task.await_many(Enum.map(tasks, &elem(&1, 1)), timeout)
  |> Enum.zip(tool_calls)
  |> Enum.map(fn {result, call} -> {call.id, result} end)
end
```

---

## Enhancement 2: Macro-Driven Tool DX

**Proposal:** Use `use AgentTool` macro to auto-generate Ecto schemas from function attributes. Change signature to `execute(tool_struct, context_map)`.

**Current design:** Already uses `use AgentFramework.Tool` and passes context. The macro generates minimal boilerplate.

**Evaluation:**

| Aspect | Assessment |
|--------|------------|
| Merit | Partial. Context is already passed (Dim 7). Schema boilerplate is intentional for explicit validation. |
| BEAM fit | Neutral. Macros are idiomatic but can obscure behavior. |
| Complexity | Medium. More macro magic = harder debugging. |
| Risk | Medium. Auto-generated schemas may not capture all validation needs. |

**Recommendation:** **ALREADY ADDRESSED / PARTIAL SKIP**

Our current design already:
1. Has `use AgentFramework.Tool` macro
2. Passes context: `execute(params, context)`
3. Uses explicit Ecto schemas for compile-time validation

What we could adopt:
- `@field_descriptions` module attribute for auto-generating JSON Schema (already in design)
- Macro-generated `changeset/2` with sensible defaults (opt-in)

The critique about "manually writing Ecto schemas" is actually a feature—explicit schemas catch errors at compile time and self-document the tool interface.

**No design change needed.** Current approach balances DX with explicitness.

---

## Enhancement 3: State-Aware "Let It Crash"

**Proposal:** On crash, inject a System Message telling the LLM the previous path crashed, prompting a different strategy.

**Current design:** Checkpoint recovery restores to last stable state (Dim 12). Max iterations prevent infinite loops. ToolError feeds errors back to LLM.

**Evaluation:**

| Aspect | Assessment |
|--------|------------|
| Merit | Low. Designing for crashes is an anti-pattern. |
| BEAM fit | Poor. Misunderstands "let it crash" philosophy. |
| Complexity | N/A |
| Risk | High. Normalizes crashes as control flow. |

**Recommendation:** **SKIP**

This proposal conflates "let it crash" (a safety net for unexpected failures) with "design for crashing" (using crashes as a recovery mechanism). These are opposites.

**Idiomatic Elixir approach:**
1. **Expected failures** → `{:ok, _} | {:error, _}` tuples, handled explicitly
2. **Validation at boundaries** → Ecto changesets reject bad data before it propagates
3. **Crashes are exceptional** → Supervisor restarts are for truly unexpected failures, not normal operation

If we're injecting "you crashed, try again" messages, we've admitted the system crashes regularly—which indicates design flaws that should be fixed, not accommodated.

**Our existing design already handles this correctly:**
- **ToolError** feeds execution failures back to LLM with context (Dim 7, 12)
- **Checkpoints** preserve state in PostgreSQL, independent of process lifecycle (Dim 15)
- **Max iterations** bound any loops (Dim 12)
- **Ecto changesets** validate all inputs at boundaries

**State preservation without crash-design:**
- ETS tables survive individual process crashes (owned by supervisor)
- Write-behind persistence ensures PostgreSQL has durable state
- Session recovery loads from checkpoint, not from crashed process memory

**No design change.** Defensive programming and explicit error handling are the correct approach.

---

## Enhancement 4: Reactive Event-Driven Agents

**Proposal:** Add `handle_event/2` callback to SessionController. Agents subscribe to PubSub topics for autonomous operation.

**Current design:** Request/Response model—sessions start on user request and process toward goal.

**Evaluation:**

| Aspect | Assessment |
|--------|------------|
| Merit | Medium. Enables new use cases (monitoring agents, CI agents). Not required for core research agent use case. |
| BEAM fit | Excellent. PubSub subscription is trivial. |
| Complexity | Medium. Requires rethinking session lifecycle (when does an autonomous agent "end"?). |
| Risk | Medium. Scope creep. Changes mental model from "task executor" to "daemon." |

**Recommendation:** **DEFER to Phase 2**

This is a valid enhancement but represents a different product shape. Our target use cases (research agents, multi-step workflows with approval gates) are request/response.

Adding autonomous agents raises questions:
- Billing model? (autonomous agents could run indefinitely)
- Resource limits? (how many tools can an unsupervised agent call?)
- Security? (what can an agent do without human approval?)

**Design note for future:**
```elixir
# Phase 2: Add to SessionController
def handle_info({:pubsub, topic, event}, state) do
  if should_wake?(state.config, event) do
    {:noreply, state, {:continue, {:process_event, event}}}
  else
    {:noreply, state}
  end
end

def handle_continue({:process_event, event}, state) do
  # Treat event as "user message" equivalent
  # Run planning/execution loop
end
```

**No design change now.** Document as Phase 2 feature.

---

## Enhancement 5: Event Sourcing as Source of Truth

**Proposal:** Replace state snapshots + events with pure event sourcing. Session state reconstructed by fold over event stream.

**Current design:** Hybrid—PostgreSQL stores checkpoints (snapshots), Time Travel stores events. ETS is ephemeral cache.

**Evaluation:**

| Aspect | Assessment |
|--------|------------|
| Merit | Low for our use case. Event sourcing solves DDD/CQRS problems we don't have. |
| BEAM fit | Neutral. Elixir handles immutability well, but that doesn't mean we need event sourcing. |
| Complexity | High. Event versioning, replay latency, still need snapshots for performance. |
| Risk | High. Importing DDD patterns without matching problem shape. |

**Recommendation:** **SKIP**

Event sourcing is a DDD/CQRS pattern that solves specific problems:
- Audit requirements where you must prove what happened
- Multiple projections from the same event stream
- Temporal queries ("what was state on date X?")

Our agent framework doesn't have these requirements:

| Need | Our Solution | Event Sourcing Required? |
|------|--------------|--------------------------|
| Fast recovery | Load checkpoint from PostgreSQL | No |
| Debugging | Query event log for step history | No (events as log, not source of truth) |
| State persistence | Write-behind to PostgreSQL | No |
| Time travel | Snapshot + query events between | No |

**Our hybrid is simpler and sufficient:**
- **Checkpoints** = source of truth for state recovery
- **Events** = append-only log for debugging/observability
- **ETS** = hot cache, ephemeral

If we adopted full event sourcing:
- Events become source of truth → schema versioning critical
- State derived by replay → latency for long sessions
- Still need snapshots for performance → back to hybrid anyway

**No design change.** Current separation of concerns (checkpoints for recovery, events for debugging) is correct.

---

## Summary

| Enhancement | Recommendation | Rationale |
|-------------|----------------|-----------|
| 1. Scatter-Gather | **ADOPT** | Clear win for parallel tool execution |
| 2. Macro DX | **ALREADY ADDRESSED** | Current design has macro + context |
| 3. State-Aware Crash | **SKIP** | Anti-pattern; defensive programming is correct approach |
| 4. Reactive Agents | **DEFER** | Phase 2 scope; different product shape |
| 5. Event Sourcing | **SKIP** | DDD pattern that doesn't match our problem shape; hybrid is simpler |

---

## Design Document Updates

### Added: Error Philosophy (Design Principle #6)

Added explicit documentation of defensive programming approach to `elixir-design.md`:

- **Result Tuples Over Exceptions** - `{:ok, _} | {:error, _}` pattern
- **Validation at Boundaries** - Ecto changesets at entry points
- **Explicit Error Propagation** - Tagged tuples with context
- **LLM Error Feedback** - ToolError enables self-correction
- **Crashes Are Exceptional** - Supervisors for unexpected failures only

This codifies the philosophy that made Enhancement #3 (State-Aware Crash) unnecessary.

---

### Added: Parallel Tool Execution (Scatter-Gather)

Added to `elixir-design.md`:

1. **Session state change**: `pending_task: reference()` → `pending_tasks: %{reference() => pending_task_meta()}`

2. **New section**: "Parallel Tool Execution (Scatter-Gather)" documenting:
   - Why parallel matters (latency comparison table)
   - StepExecutor implementation with `Task.Supervisor.async_nolink`
   - Partial failure handling (all results returned to LLM)
   - Resource bounds (`@max_concurrent_tools`, `@tool_batch_timeout`)

3. **Design Decisions Summary**: Updated Dimension 7 to include "parallel execution (scatter-gather)"

---

## Session Summary

### Enhancements Evaluated

| Enhancement | Decision | Action |
|-------------|----------|--------|
| 1. Scatter-Gather | ADOPT | Added to design |
| 2. Macro DX | ALREADY ADDRESSED | No change |
| 3. State-Aware Crash | SKIP | Anti-pattern |
| 4. Reactive Agents | DEFER | Phase 2 |
| 5. Event Sourcing | SKIP | DDD pattern mismatch |

### Design Document Updates

1. **Error Philosophy** - Added as Design Principle #6
2. **Parallel Tool Execution** - New section with implementation details
3. **Session state type** - Updated to support concurrent tasks

---
