# Elixir Design Session - 2025-12-27

## Session Context
- **Prior sessions**:
  - `2025-12-24-0639.md` (Dimensions 1-13)
  - `2025-12-25-0409.md` (Dimensions 14-17, gap resolution)
- **Consolidated design**: `docs/elixir-design.md` (19 dimensions documented)
- **Critique document**: `docs/enhancing_elixir_spec.md` (6 refinement areas)
- **Analysis artifacts**:
  - `reports/synthesis/comparison-matrix.md`
  - `reports/synthesis/antipatterns.md`
  - `reports/synthesis/reference-architecture.md`
- **Session goal**: Evaluate critique recommendations, adopt what aligns with architecture

---

## Prior Session Summary

### Completed Dimensions (19 in design doc)

| # | Dimension | Decision |
|---|-----------|----------|
| 1 | Core Architecture | Deep Agents via GenServer + Task |
| 2 | Process Structure | SessionController GenServer + Task.async for steps |
| 3 | State Model | PostgreSQL + Redis with Ecto embedded schemas |
| 4 | Message Protocol | Lightweight reference structs (session_id, plan_id, step_index) |
| 5 | ETS Layout | 5 tables: :sessions, :messages, :context, :cache, :sub_agent_contexts |
| 6 | Clustering | Node affinity + ex_hash_ring + write-behind persistence |
| 7 | Tool System | Ecto schemas, introspection-based JSON schema, Task isolation |
| 8 | LLM Integration | Req + Behaviour adapters, PubSub streaming, Hammer, :fuse |
| 9 | Memory/Context | Token budget + eviction, pgvector + pg_bm25, tiktoken NIF |
| 10 | Multi-Agent | SessionController orchestrates sub-agents; hub-and-spoke |
| 11 | Observability | Telemetry + OpenTelemetry, step-level granularity |
| 12 | Error Handling | Feed errors to LLM, checkpoint recovery, max iterations |
| 13 | Interrupts/Breakpoints | Hybrid (step-level + runtime registry), timeout with default |
| 14 | Human-in-the-Loop | Step type + tool, PubSub → Phoenix Channel → WebSocket |
| 15 | Time Travel Debugging | Hybrid snapshots + events, L1 view-only inspection |
| 16 | Sub-Agent Architecture | Task-based with ETS context; ephemeral processes, persistent context |
| 17 | Artifact/Workspace Memory | S3-compatible storage with behaviour abstraction |
| 18 | System Prompts | EEx templates in priv/prompts/; directory override |
| 19 | Context Handoff | Hybrid extraction: code facts + LLM interpretation |

---

## Critique Evaluation

### Recommendations from `enhancing_elixir_spec.md`

| # | Recommendation | Verdict | Rationale |
|---|----------------|---------|-----------|
| 1 | BSP Supersteps | **Skip** | GenServer already provides deterministic ordering; solves problem we don't have |
| 2 | 50/30/20 Memory | **Adopt** | Directly addresses #1 anti-pattern (unbounded memory); fits ContextBuilder |
| 3 | Tool Sandboxing | **Adopt (interface only)** | Per-tool setting; design interface to external sandbox, not sandbox itself |
| 4 | Error-as-Data | **Adopt** | Formalizes existing decision with ToolError schema |
| 5 | Tagged IDs | **Skip** | Marginal benefit in Elixir; Ecto schemas provide validation at boundaries |
| 6 | Agno Taxonomy | **Skip (defer analysis)** | Their abstractions ≠ ours; save event analysis as future research task |

---

## Dimension 20: Hierarchical Memory Strategy

**Problem Statement:**
The current design specifies "token budget + eviction" without defining the eviction strategy. Generic FIFO eviction loses important context.

**Decision:**
**Choice**: 50/30/20 Three-Tier Compression

**Architecture:**
```
Token Budget Allocation:
├── 50% Recent Messages (verbatim, most recent first)
├── 30% Historical Summary (LLM-compressed rolling summary)
└── 20% Semantic Retrieval (pgvector similarity search)
```

**Implementation in ContextBuilder:**
```elixir
defmodule AgentFramework.Memory.ContextBuilder do
  @default_ratios %{recent: 0.5, summary: 0.3, semantic: 0.2}

  def build(session_id, token_budget, opts \\ []) do
    ratios = Keyword.get(opts, :ratios, @default_ratios)
    query_embedding = Keyword.get(opts, :query_embedding)

    recent = load_recent_messages(session_id,
      budget: trunc(token_budget * ratios.recent))

    summary = load_or_generate_summary(session_id,
      budget: trunc(token_budget * ratios.summary),
      exclude_message_ids: Enum.map(recent, & &1.id))

    semantic = retrieve_semantic(session_id,
      budget: trunc(token_budget * ratios.semantic),
      embedding: query_embedding,
      exclude_message_ids: Enum.map(recent, & &1.id))

    assemble_context([recent, summary, semantic])
  end

  defp load_or_generate_summary(session_id, opts) do
    case get_cached_summary(session_id) do
      {:ok, summary} -> summary
      :miss -> generate_and_cache_summary(session_id, opts)
    end
  end
end
```

**Summary Generation (async, background):**
- Triggered when message count exceeds threshold
- Runs as background Task, doesn't block agent loop
- Cached in ETS with TTL, persisted to Postgres

**Rationale:**
- Addresses unbounded memory (anti-pattern #1)
- Preserves recent context for immediate relevance
- Summaries capture intent without full token cost
- Semantic retrieval brings back long-term facts when relevant

**Trade-offs accepted:**
- Summary generation adds LLM cost (amortized over many requests)
- Semantic retrieval requires embedding computation
- Ratios may need tuning per use case (made configurable)

---

## Dimension 21: Sandbox Interface

**Problem Statement:**
Code execution tools pose security risks. BEAM Tasks provide concurrency isolation but not security isolation. We need an interface to external sandboxes without implementing the sandbox itself.

**Decision:**
**Choice**: Behaviour-based interface with WebSocket streaming to external sandbox

**Design Scope:**
- Define the interface (behaviour + protocol)
- Document communication requirements
- Do NOT implement sandbox runtime (complex, separate concern)

**Sandbox Behaviour:**
```elixir
defmodule AgentFramework.Sandbox do
  @moduledoc """
  Behaviour for sandbox implementations.

  Sandboxes execute untrusted code in isolated environments.
  Communication is streaming (code execution may produce incremental output).
  """

  @type execution_id :: String.t()
  @type language :: :python | :javascript | :elixir | :shell
  @type resource_limits :: %{
    timeout_ms: pos_integer(),
    memory_mb: pos_integer(),
    cpu_shares: pos_integer()
  }

  @type execution_request :: %{
    id: execution_id(),
    language: language(),
    code: String.t(),
    stdin: String.t() | nil,
    env: %{String.t() => String.t()},
    limits: resource_limits()
  }

  @type stream_event ::
    {:stdout, String.t()}
    | {:stderr, String.t()}
    | {:status, :running | :completed | :failed | :timeout | :oom}
    | {:exit_code, integer()}
    | {:error, String.t()}

  @type execution_result :: %{
    id: execution_id(),
    exit_code: integer() | nil,
    stdout: String.t(),
    stderr: String.t(),
    duration_ms: pos_integer(),
    status: :completed | :failed | :timeout | :oom
  }

  @doc "Start a connection to the sandbox environment"
  @callback connect(opts :: keyword()) :: {:ok, pid()} | {:error, term()}

  @doc "Execute code, streaming events to caller"
  @callback execute(pid(), execution_request()) :: {:ok, execution_id()} | {:error, term()}

  @doc "Cancel a running execution"
  @callback cancel(pid(), execution_id()) :: :ok | {:error, term()}

  @doc "Disconnect from sandbox"
  @callback disconnect(pid()) :: :ok
end
```

**WebSocket Protocol:**

The sandbox client maintains a WebSocket connection to a sandbox server. Messages are JSON-encoded.

```
Client → Server (execute):
{
  "type": "execute",
  "id": "exec_abc123",
  "language": "python",
  "code": "print('hello')\nfor i in range(5): print(i)",
  "stdin": null,
  "env": {"API_KEY": "..."},
  "limits": {
    "timeout_ms": 30000,
    "memory_mb": 256,
    "cpu_shares": 512
  }
}

Server → Client (streaming events):
{"type": "status", "id": "exec_abc123", "status": "running"}
{"type": "stdout", "id": "exec_abc123", "data": "hello\n"}
{"type": "stdout", "id": "exec_abc123", "data": "0\n1\n2\n"}
{"type": "stdout", "id": "exec_abc123", "data": "3\n4\n"}
{"type": "status", "id": "exec_abc123", "status": "completed"}
{"type": "exit_code", "id": "exec_abc123", "code": 0}

Client → Server (cancel):
{"type": "cancel", "id": "exec_abc123"}
```

**Framework Integration:**
```elixir
defmodule AgentFramework.Tools.CodeExecute do
  use AgentFramework.Tool

  @tool_description "Execute code in a sandboxed environment"

  @impl AgentFramework.Tool
  def sandbox_mode, do: :external  # Requires sandbox connection

  embedded_schema do
    field :language, Ecto.Enum, values: [:python, :javascript, :shell]
    field :code, :string
    field :timeout_ms, :integer, default: 30_000
  end

  @impl AgentFramework.Tool
  def execute(%__MODULE__{} = params, context) do
    sandbox = context.sandbox_connection

    request = %{
      id: generate_id(),
      language: params.language,
      code: params.code,
      limits: %{timeout_ms: params.timeout_ms, memory_mb: 256, cpu_shares: 512}
    }

    case AgentFramework.Sandbox.execute(sandbox, request) do
      {:ok, exec_id} ->
        collect_streaming_result(sandbox, exec_id)
      {:error, reason} ->
        {:error, %ToolError{tool_name: "code_execute", message: reason}}
    end
  end
end
```

**Tool Behaviour Update:**
```elixir
defmodule AgentFramework.Tool do
  @type sandbox_mode :: :none | :external

  @callback sandbox_mode() :: sandbox_mode()
  @callback execute(struct(), context :: map()) :: {:ok, term()} | {:error, ToolError.t()}

  # Default implementation
  defmacro __using__(_opts) do
    quote do
      @behaviour AgentFramework.Tool

      def sandbox_mode, do: :none
      defoverridable sandbox_mode: 0
    end
  end
end
```

**Vision:**
The sandbox server (likely WASM-based, e.g., using Extism or similar) is a separate deployable component. It:
- Runs in isolated environment (container, WASM runtime)
- Enforces resource limits (CPU, memory, time, network)
- Streams output for long-running executions
- Supports multiple languages via polyglot WASM
- Stateless per execution (fresh environment each time)

**What We Build:**
- `AgentFramework.Sandbox` behaviour (interface contract)
- `AgentFramework.Sandbox.WebSocketClient` (connects to external sandbox)
- Tool execution flow that routes sandboxed tools through client

**What We Don't Build:**
- The sandbox server itself
- WASM runtime integration
- Container orchestration

**Rationale:**
- Clear separation of concerns (agent framework vs sandbox runtime)
- WebSocket enables streaming for long-running code
- Behaviour allows swapping sandbox implementations (WASM, Docker, remote service)
- Explicit `sandbox_mode/0` makes security requirements visible per tool

**Trade-offs accepted:**
- Dependency on external sandbox service for code execution
- Network latency for sandbox communication
- Must deploy/manage sandbox infrastructure separately

---

## Refinement: ToolError Schema

**Addition to Tool System (Dimension 7):**

```elixir
defmodule AgentFramework.Schemas.ToolError do
  @moduledoc """
  Structured error from tool execution.
  Provides enough context for LLM to understand and potentially correct.
  """

  use Ecto.Schema

  @type t :: %__MODULE__{
    tool_name: String.t(),
    error_type: :validation | :execution | :timeout | :sandbox | :permission,
    message: String.t(),
    retryable: boolean(),
    context: map()
  }

  @primary_key false
  embedded_schema do
    field :tool_name, :string
    field :error_type, Ecto.Enum,
      values: [:validation, :execution, :timeout, :sandbox, :permission]
    field :message, :string
    field :retryable, :boolean, default: true
    field :context, :map, default: %{}  # Original args, partial results, hints
  end

  def validation_error(tool_name, message, context \\ %{}) do
    %__MODULE__{
      tool_name: tool_name,
      error_type: :validation,
      message: message,
      retryable: true,
      context: context
    }
  end

  def execution_error(tool_name, message, opts \\ []) do
    %__MODULE__{
      tool_name: tool_name,
      error_type: :execution,
      message: message,
      retryable: Keyword.get(opts, :retryable, true),
      context: Keyword.get(opts, :context, %{})
    }
  end

  def timeout_error(tool_name, timeout_ms) do
    %__MODULE__{
      tool_name: tool_name,
      error_type: :timeout,
      message: "Execution timed out after #{timeout_ms}ms",
      retryable: false,
      context: %{timeout_ms: timeout_ms}
    }
  end
end
```

**LLM Feedback Format:**
When a tool returns `{:error, %ToolError{}}`, the framework formats it for LLM context:

```elixir
def format_tool_error_for_llm(%ToolError{} = error) do
  """
  Tool `#{error.tool_name}` failed.
  Error type: #{error.error_type}
  Message: #{error.message}
  #{if error.retryable, do: "This error may be resolved by trying again with different parameters.", else: "This error is not retryable."}
  #{if map_size(error.context) > 0, do: "Context: #{inspect(error.context)}", else: ""}
  """
end
```

---

## Session Summary

**Date**: 2025-12-27
**Decisions Made**: 3 (adopted 2 new dimensions + 1 refinement)
**Decisions Deferred**: 1 (Agno event analysis → TODO-ANALYSIS.md)
**Decisions Skipped**: 2 (BSP supersteps, tagged IDs)

### New Dimensions

| # | Dimension | Decision |
|---|-----------|----------|
| 20 | Hierarchical Memory Strategy | 50/30/20 split (recent/summary/semantic) |
| 21 | Sandbox Interface | Behaviour + WebSocket protocol; interface only, no runtime |

### Refinements

| Area | Change |
|------|--------|
| Tool System | Added `ToolError` schema for structured error feedback |
| Tool Behaviour | Added `sandbox_mode/0` callback (default `:none`) |

### Updated Module Structure

```
lib/agent_framework/
├── memory/
│   ├── context_builder.ex      # Now implements 50/30/20 strategy
│   ├── summary_generator.ex    # Background summary generation
│   └── ...
├── sandbox/
│   ├── behaviour.ex            # Sandbox behaviour definition
│   └── websocket_client.ex     # WebSocket client to external sandbox
├── schemas/
│   ├── tool_error.ex           # NEW: Structured tool errors
│   └── ...
└── tools/
    ├── behaviour.ex            # Updated: sandbox_mode/0 callback
    └── builtin/
        └── code_execute.ex     # Uses sandbox_mode: :external
```

### Deferred

- Agno 17-event taxonomy analysis → `TODO-ANALYSIS.md`

---

## Next Steps

1. Update `docs/elixir-design.md` with dimensions 20-21 and refinements
2. Create `TODO-ANALYSIS.md` with Agno event analysis task
3. Continue session or end

