# Elixir Design Session - 2025-12-24

## Session Context
- Analysis artifacts used:
  - `reports/synthesis/comparison-matrix.md`
  - `reports/synthesis/antipatterns.md`
  - `reports/synthesis/reference-architecture.md`
- Session goal: Design an idiomatic Elixir agent framework informed by architectural forensics of 15 Python frameworks

---

## Key Patterns Discovered (Conceptual Summary)

### Reasoning Patterns
- **ReAct**: Thought-Action-Observation loop (general-purpose tool use)
- **Function Calling**: Native LLM function calls, no text parsing
- **Plan-and-Solve**: Explicit planning phase before execution
- **Graph-Based**: User-defined state machines for complex workflows

### State Management
- **Immutability**: Frozen dataclasses with copy-on-write (best practice)
- **Reducers**: Custom merge logic for aggregating state (LangGraph pattern)
- **Checkpointing**: Persistence for resume/recovery

### Tool Interface
- **Introspection-based schemas**: Auto-generate from type hints + docstrings
- **Decorator registration**: `@tool` pattern dominant
- **Error-as-data**: Feed errors to LLM for self-correction
- **Parallel execution**: Concurrent tool calls with limits

### Memory/Context
- **Three-tier hierarchy**: 50% recent, 30% summarized, 20% semantic (Agent-Zero)
- **Token budgets**: Pre-flight estimation, automatic eviction
- **Summarization**: LLM-based compression before eviction

### Multi-Agent Coordination
- **Handoff**: Tool-based agent switching (Swarm pattern)
- **Graph-based**: State machines with conditional edges
- **Workforce/Society**: PARALLEL/PIPELINE/LOOP orchestration modes
- **Pub/Sub**: Message bus for event-driven coordination

### Error Handling Philosophy
- **Three-layer retry**: Graph validation, tool retry with feedback, HTTP transient
- **Circuit breakers**: Track failure rates, auto-disable failing components
- **Graceful degradation**: Max iterations with partial results

### Critical Anti-patterns to Avoid
1. Unbounded memory growth (80% of frameworks)
2. Silent exception swallowing
3. No max iterations (infinite loop risk)
4. Mutable state without thread safety
5. No tool sandboxing
6. Configuration god objects (250+ fields)
7. Deep inheritance hierarchies
8. String-based identifiers for routing
9. Global mutable state
10. Sync wrapped in async.to_thread

---

## Design Dimensions

### Dimension 1: Core Architecture Pattern

**Discussion:**
- Rejected simple loop patterns (ReAct, FunctionCalling) as too shallow
- Adopted **Deep Agents** pattern from philschmid.de:
  1. Explicit Planning - External task plan, updated after each action
  2. Hierarchical Delegation - Orchestrator + specialized sub-agents
  3. Persistent Memory - External storage as source of truth
  4. Extreme Context Engineering - Multi-thousand-token instructions

**Decision:**
**Choice**: Deep Agents architecture via Broadway pipeline
**Rationale**:
- Broadway provides batching, rate limiting, telemetry, graceful shutdown out of box
- Natural fit for hierarchical delegation (producer = planner, processors = sub-agents)
- Battle-tested for production Elixir systems
**Trade-offs accepted**:
- More complex than simple GenServer loop
- Broadway learning curve

---

### Dimension 2: Process Structure

**Discussion:**
- LangGraph uses state+reducers with graph-based control flow
- Considered gen_statem (handle_event_function mode for dynamic states)
- Broadway subsumes much of what we'd build manually

**Decision:**
**Choice**: Broadway pipeline with GenStage producer using :queue
**Rationale**:
- Producer parses tasks into plan steps, emits as messages
- Processors are sub-agents (researcher, coder, writer)
- Batcher synthesizes results
- Plan state lives in ETS, updated after each step
**Trade-offs accepted**:
- Broadway is opinionated
- Less flexibility than raw gen_statem

**Reference Implementation**: https://github.com/Dowwie/hermes/blob/main/lib/hermes/ingest/producer.ex

---

### Dimension 3: State Model

**Discussion:**
- Deep Agents require persistent external state (pillar 3)
- Immutability critical (anti-pattern: mutable state without thread safety)
- Need to balance hot path performance with durability

**Decision:**
**Choice**: PostgreSQL + Redis with Ecto embedded schemas
**Rationale**:
- Postgres (via Ecto): Plan state, message history, checkpoints - durable, queryable
- Redis (via Redix): Token cache, rate limits, pub/sub - fast, ephemeral
- Ecto embedded schemas: Changesets for controlled updates (like reducers), validation built-in, seamless JSONB persistence
**Trade-offs accepted**:
- Network latency vs ETS
- Two external dependencies
- Schema management overhead

**State Structs**: Ecto embedded schemas with:
- `@primary_key false` for embedded use
- Ecto.Enum for role types
- Changesets for validation and updates
- embeds_many for nested structures (Plan -> Steps)

---

### Dimension 4: Message Protocol + State Distribution

**Discussion:**
- Elixir idiom: pass references, not payloads
- Heavy state in ETS (or backing store), messages carry identifiers
- Clustering requirements change ETS design significantly

**Decisions:**

#### Message Format
**Choice**: Lightweight reference struct
```elixir
defmodule AgentFramework.Message do
  @type t :: %__MODULE__{
    session_id: String.t(),      # ETS lookup key for session state
    plan_id: String.t(),         # Current plan being executed
    step_index: non_neg_integer(), # Which step we're processing
    metadata: map()              # Telemetry, timestamps, etc.
  }
end
```

#### ETS Table Layout (Heuristic-Driven)
**Choice**: 4 tables organized by access pattern

| Table | Concurrency | Persisted | Purpose |
|-------|-------------|-----------|---------|
| `:sessions` | `:write_concurrency` | Yes | Plan state, orchestration |
| `:messages` | `:write_concurrency` | Yes | Chat history (ordered) |
| `:context` | `:read_concurrency` | Yes | Assembled prompt context |
| `:cache` | `:read_concurrency` | No | Token counts, dedup (ephemeral) |

**Heuristics applied:**
- Separate tables when read/write patterns differ
- Separate when different processes access simultaneously (reduces contention)
- Group by lifecycle (cleanup together)
- `:read_concurrency` for read-heavy, `:write_concurrency` for write-heavy

#### Clustering Strategy
**Choice**: High Availability via Node Affinity + External Persistence
**Rationale**:
- Consistent hash ring routes sessions to owning node
- ETS as local hot cache, Postgres as durability layer
- Write-behind persistence (async, configurable flush interval)
- On node failure: ring rehashes, new owner loads session from Postgres

**Key Library**: `ex_hash_ring` (https://github.com/discord/ex_hash_ring) for consistent hashing

**Architecture:**
```
┌─────────────────────────────────────────────────────────────┐
│                      libcluster                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │   Node A    │    │   Node B    │    │   Node C    │      │
│  │ ETS (local) │    │ ETS (local) │    │ ETS (local) │      │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘      │
│         └──────────────────┼──────────────────┘              │
│                            ▼                                 │
│                   ┌─────────────────┐                        │
│                   │   PostgreSQL    │◄── Write-behind        │
│                   └─────────────────┘                        │
│              ┌─────────────────────┐                         │
│              │   ex_hash_ring      │◄── Session routing      │
│              └─────────────────────┘                         │
└─────────────────────────────────────────────────────────────┘
```

---

### Dimension 5: Tool System

**Discussion:**
- Mapped Python patterns to Elixir native capabilities
- Introspection is Elixir strength - leverage it for schema generation
- Tools should be Ecto embedded schemas for validation consistency

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Tool structure | Ecto embedded schemas with changeset validation |
| Schema generation | Introspection via `__schema__/1` → JSON schema |
| Tool description (LLM) | `@tool_description` module attribute |
| Developer docs | `@moduledoc` (separate concern) |
| Field descriptions | `@field_descriptions` map or custom field macro |
| Execution isolation | Task with timeout + kill |
| Parallel execution | `Task.async_stream` with configurable `max_concurrency` |
| Error handling | `{:ok, _} | {:error, _}` tuples, errors fed to LLM |
| Registration | `@after_compile` hook → ETS registry |

**Example Tool:**
```elixir
defmodule MyTools.WebSearch do
  @moduledoc """
  Wraps Serper API for web search. Rate limited to 100 req/min.
  """

  use AgentFramework.Tool

  @tool_description """
  Search the web for current information. Use when:
  - User asks about recent events
  - User needs up-to-date facts
  """

  @field_descriptions %{
    query: "The search query to execute",
    max_results: "Maximum number of results to return (1-100)"
  }

  @primary_key false
  embedded_schema do
    field :query, :string
    field :max_results, :integer, default: 10
  end

  def changeset(tool, attrs) do
    tool
    |> cast(attrs, [:query, :max_results])
    |> validate_required([:query])
    |> validate_number(:max_results, greater_than: 0, less_than_or_equal_to: 100)
  end

  @impl AgentFramework.Tool
  def execute(%__MODULE__{query: query, max_results: max}) do
    # Actual implementation
    {:ok, results}
  end
end
```

---

### Dimension 6: LLM Integration

**Discussion:**
- Reference LiteLLM for unified provider interface design
- Behaviour + adapters pattern for multi-provider support
- Need both internal processing and real-time UI streaming

**Decisions:**

| Aspect | Choice |
|--------|--------|
| HTTP Client | Req |
| Multi-provider | Behaviour + adapters (OpenAI, Anthropic, etc.) |
| Reference design | LiteLLM (Python) for API unification patterns |
| Streaming | Req callback + PubSub broadcast |
| UI topic | `"llm:#{session_id}"` |
| Rate limiting | Hammer (token bucket per provider) |
| Transient retry | Req retry plugin (exponential backoff) |
| Persistent failure | `:fuse` circuit breaker |

**Streaming Architecture:**
```elixir
# In LLM adapter
Req.get!(url,
  into: fn {:data, chunk}, acc ->
    # Broadcast to UI subscribers
    Phoenix.PubSub.broadcast(MyApp.PubSub, "llm:#{session_id}", {:chunk, chunk})
    # Accumulate for internal consumer
    {:cont, acc <> chunk}
  end
)
```

---

### Dimension 7: Memory/Context Management

**Discussion:**
- Token budget management critical
- PostgreSQL with pgvector + pg_bm25 for unified storage
- Compression strategy needs research

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Strategy | Token budget + eviction |
| Vector store | PostgreSQL + pgvector |
| Text search | PostgreSQL + pg_bm25 |
| Token counting | Tiktoken via NIF or Port |
| Compression | Research needed (LLM summarization as baseline) |
| Hybrid search | Vector + BM25 in single Postgres query |

**Research items for later:**
- Elixir tiktoken bindings (existing or build NIF)
- Compaction alternatives to LLM summarization

---

### Dimension 8: Multi-Agent Coordination

**Discussion:**
- LangGraph pattern: state-based conditional routing with external control loop
- Most idiomatic Elixir: GenServer for control + Broadway for execution
- No direct peer-to-peer sub-agent communication

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Control pattern | GenServer per session (SessionController) |
| Execution | Broadway shared pipeline |
| State machine logic | Pattern matching in GenServer callbacks |
| Condition evaluation | After each step completion |
| Work dispatch | SessionController enqueues to Broadway producer |
| Sub-agent communication | Via ETS state (no direct peer-to-peer) |
| Discovery | Static processor pools, dynamic session controllers |

**Architecture:**
```
┌────────────────────────────────────────────────────────────────────┐
│                         Session Layer                               │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐        │
│  │ SessionCtrl 1  │  │ SessionCtrl 2  │  │ SessionCtrl N  │        │
│  │ (GenServer)    │  │ (GenServer)    │  │ (GenServer)    │        │
│  └───────┬────────┘  └───────┬────────┘  └───────┬────────┘        │
│          │                   │                   │                  │
│          └───────────────────┼───────────────────┘                  │
│                              │ enqueue steps                        │
└──────────────────────────────┼──────────────────────────────────────┘
                               ▼
┌──────────────────────────────────────────────────────────────────────┐
│                       Broadway Pipeline                               │
│                                                                       │
│  [Producer] → [Researcher] → ┐                                        │
│            → [Coder]     → ─┼─→ [Batcher] → step_complete message    │
│            → [Writer]    → ─┘                                        │
└──────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
                    back to SessionController
```

---

### Dimension 9: Observability

**Discussion:**
- Elixir has excellent built-in observability (Telemetry, Logger, OpenTelemetry)
- Broadway provides built-in telemetry events

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Granularity | Step-level |
| Metrics | Telemetry events |
| Traces | OpenTelemetry |
| Logging | Logger with structured metadata |
| Broadway | Use built-in Broadway telemetry events |

**Telemetry Events:**
```elixir
# Session lifecycle
[:agent_framework, :session, :start]
[:agent_framework, :session, :complete]
[:agent_framework, :session, :error]

# Step lifecycle
[:agent_framework, :step, :start]
[:agent_framework, :step, :complete]
[:agent_framework, :step, :error]

# LLM calls
[:agent_framework, :llm, :request]
[:agent_framework, :llm, :response]
[:agent_framework, :llm, :error]

# Tool execution
[:agent_framework, :tool, :execute]
[:agent_framework, :tool, :complete]
[:agent_framework, :tool, :error]
```

**OpenTelemetry Spans:**
- Session span (parent)
  - Step spans (children)
    - LLM spans
    - Tool spans

---

### Dimension 10: Error Handling

**Discussion:**
- "Let it crash" works but losing session context is expensive
- LLM calls are expensive (tokens, latency)
- Need checkpoint-based recovery

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Tool errors | Immediate feed to LLM (no automatic retry) |
| Max iterations | Configurable per session (default + override) |
| LLM API failures | Retry with exponential backoff (Req retry + :fuse) |
| Session recovery | From checkpoint (Postgres persistence) |
| Supervision | Let it crash for unexpected errors, restart session from checkpoint |

**Checkpoint Strategy:**
- Checkpoint = snapshot of session state at a recoverable point
- Persist to Postgres after each step completion (write-behind)
- On node crash + restart: load latest checkpoint, resume from there
- Checkpoints include: plan state, message history, current step index

---

## Session Summary

**Session completed**: 2025-12-24

**All 10 dimensions decided:**
1. Core Architecture: Deep Agents pattern via Broadway pipeline
2. Process Structure: Broadway + GenStage producer with :queue
3. State Model: PostgreSQL + Redis with Ecto embedded schemas
4. Message Protocol + Distribution: Reference structs, 4 ETS tables, ex_hash_ring, write-behind
5. Tool System: Ecto schemas, introspection, @tool_description, Task isolation
6. LLM Integration: Req + Behaviour adapters, streaming via PubSub, Hammer rate limiting, :fuse circuit breaker
7. Memory/Context: Token budget + eviction, pgvector + pg_bm25, tiktoken NIF
8. Multi-Agent Coordination: SessionController GenServer + Broadway execution pipeline
9. Observability: Telemetry + OpenTelemetry, step-level granularity
10. Error Handling: Feed errors to LLM, checkpoint recovery, configurable max iterations

**Key Libraries:**
- Broadway (pipeline processing)
- Ecto (data modeling, validation)
- Req (HTTP)
- ex_hash_ring (consistent hashing)
- Hammer (rate limiting)
- :fuse (circuit breaker)
- Phoenix.PubSub (streaming)
- Telemetry + OpenTelemetry (observability)
- pgvector + pg_bm25 (vector/text search)

**Research items deferred:**
- Tiktoken Elixir bindings
- Compaction alternatives to LLM summarization
- LiteLLM analysis for provider unification patterns

**Next steps:**
1. Produce architecture sketch with supervision tree
2. Define module structure
3. Create type specifications
4. Begin implementation (recommended order in architecture sketch)

---

## Architecture Sketch

### Supervision Tree

```
                            ┌─────────────────────────────┐
                            │    AgentFramework.App       │
                            │    (Application)            │
                            └─────────────┬───────────────┘
                                          │
                    ┌─────────────────────┼─────────────────────┐
                    │                     │                     │
                    ▼                     ▼                     ▼
        ┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐
        │  ETS Supervisor   │  │  Infrastructure   │  │  Session          │
        │  (one_for_one)    │  │  Supervisor       │  │  Supervisor       │
        └─────────┬─────────┘  └─────────┬─────────┘  └─────────┬─────────┘
                  │                      │                      │
      ┌───────────┼───────────┐          │          ┌───────────┼───────────┐
      ▼           ▼           ▼          │          ▼           ▼           ▼
   :sessions  :messages  :context        │    SessionCtrl   SessionCtrl  ...
   :cache     (ETS)      (ETS)           │    (GenServer)   (GenServer)
   (ETS)                                 │
                                         │
              ┌──────────────────────────┼──────────────────────────┐
              ▼                          ▼                          ▼
    ┌───────────────────┐    ┌───────────────────┐    ┌───────────────────┐
    │  Broadway         │    │  PersistenceWorker│    │  HashRing         │
    │  Pipeline         │    │  (GenServer)      │    │  Manager          │
    └─────────┬─────────┘    │  Write-behind     │    │  (GenServer)      │
              │              └───────────────────┘    └───────────────────┘
    ┌─────────┴─────────┐
    ▼                   ▼
  Producer           Processors
  (GenStage)         ┌─────────┬─────────┐
                     ▼         ▼         ▼
               Researcher   Coder    Writer
               (pool: 2)  (pool: 2) (pool: 1)
                     │         │         │
                     └────┬────┴────┬────┘
                          ▼         ▼
                       Batcher   Batcher
                       (default) (priority)
```

### Module Structure

```
lib/
├── agent_framework/
│   ├── application.ex              # OTP Application
│   │
│   ├── state/                      # Dimension 3 & 4: State Model
│   │   ├── ets_supervisor.ex       # Supervises ETS table owners
│   │   ├── tables.ex               # ETS table creation/access
│   │   ├── persistence_worker.ex   # Write-behind to Postgres
│   │   └── hash_ring.ex            # ex_hash_ring integration
│   │
│   ├── schemas/                    # Ecto Embedded Schemas
│   │   ├── session.ex              # Session state
│   │   ├── plan.ex                 # Plan with steps
│   │   ├── step.ex                 # Individual plan step
│   │   ├── message.ex              # Chat message
│   │   ├── context.ex              # Assembled context
│   │   └── checkpoint.ex           # Recovery checkpoint
│   │
│   ├── session/                    # Dimension 8: Coordination
│   │   ├── supervisor.ex           # DynamicSupervisor for sessions
│   │   ├── controller.ex           # GenServer per session
│   │   ├── router.ex               # Routes to owning node
│   │   └── registry.ex             # Session process registry
│   │
│   ├── pipeline/                   # Dimension 1 & 2: Broadway
│   │   ├── broadway.ex             # Broadway configuration
│   │   ├── producer.ex             # GenStage producer with :queue
│   │   ├── processors/
│   │   │   ├── researcher.ex       # Research sub-agent
│   │   │   ├── coder.ex            # Coding sub-agent
│   │   │   └── writer.ex           # Writing sub-agent
│   │   └── batcher.ex              # Result synthesis
│   │
│   ├── tools/                      # Dimension 5: Tool System
│   │   ├── behaviour.ex            # Tool behaviour definition
│   │   ├── registry.ex             # Tool registration
│   │   ├── schema.ex               # JSON schema generation
│   │   ├── executor.ex             # Task-based execution
│   │   └── builtin/
│   │       ├── web_search.ex
│   │       ├── file_read.ex
│   │       └── code_execute.ex
│   │
│   ├── llm/                        # Dimension 6: LLM Integration
│   │   ├── behaviour.ex            # Provider behaviour
│   │   ├── client.ex               # Main client (provider-agnostic)
│   │   ├── streaming.ex            # Req + PubSub streaming
│   │   ├── providers/
│   │   │   ├── openai.ex
│   │   │   ├── anthropic.ex
│   │   │   └── local.ex
│   │   ├── rate_limiter.ex         # Hammer integration
│   │   └── circuit_breaker.ex      # :fuse integration
│   │
│   ├── memory/                     # Dimension 7: Memory/Context
│   │   ├── token_counter.ex        # Tiktoken NIF wrapper
│   │   ├── context_builder.ex      # Assemble prompt context
│   │   ├── eviction.ex             # Token budget enforcement
│   │   └── search.ex               # pgvector + pg_bm25 queries
│   │
│   ├── telemetry/                  # Dimension 9: Observability
│   │   ├── events.ex               # Event definitions
│   │   ├── handlers.ex             # Telemetry handlers
│   │   └── otel.ex                 # OpenTelemetry integration
│   │
│   └── recovery/                   # Dimension 10: Error Handling
│       ├── checkpoint.ex           # Checkpoint creation/loading
│       └── supervisor_callbacks.ex # Restart-from-checkpoint logic
│
├── agent_framework.ex              # Public API
│
└── mix.exs
```

### Key Type Specifications

```elixir
# lib/agent_framework/schemas/session.ex
defmodule AgentFramework.Schemas.Session do
  use Ecto.Schema
  import Ecto.Changeset

  @type t :: %__MODULE__{
    id: String.t(),
    user_id: String.t(),
    state: :planning | :executing | :completed | :failed,
    plan: AgentFramework.Schemas.Plan.t() | nil,
    config: map(),
    max_iterations: pos_integer(),
    current_iteration: non_neg_integer(),
    created_at: DateTime.t(),
    updated_at: DateTime.t()
  }

  @primary_key {:id, :binary_id, autogenerate: true}
  embedded_schema do
    field :user_id, :string
    field :state, Ecto.Enum, values: [:planning, :executing, :completed, :failed]
    embeds_one :plan, AgentFramework.Schemas.Plan
    field :config, :map, default: %{}
    field :max_iterations, :integer, default: 20
    field :current_iteration, :integer, default: 0
    field :created_at, :utc_datetime_usec
    field :updated_at, :utc_datetime_usec
  end
end

# lib/agent_framework/schemas/plan.ex
defmodule AgentFramework.Schemas.Plan do
  use Ecto.Schema

  @type t :: %__MODULE__{
    id: String.t(),
    goal: String.t(),
    steps: [AgentFramework.Schemas.Step.t()],
    current_step_index: non_neg_integer()
  }

  @primary_key false
  embedded_schema do
    field :id, :binary_id
    field :goal, :string
    embeds_many :steps, AgentFramework.Schemas.Step
    field :current_step_index, :integer, default: 0
  end
end

# lib/agent_framework/schemas/step.ex
defmodule AgentFramework.Schemas.Step do
  use Ecto.Schema

  @type step_type :: :research | :code | :write | :review | :custom
  @type step_status :: :pending | :in_progress | :completed | :failed | :skipped

  @type t :: %__MODULE__{
    id: String.t(),
    type: step_type(),
    description: String.t(),
    status: step_status(),
    processor: atom(),
    dependencies: [String.t()],
    result: map() | nil,
    error: String.t() | nil
  }

  @primary_key false
  embedded_schema do
    field :id, :binary_id
    field :type, Ecto.Enum, values: [:research, :code, :write, :review, :custom]
    field :description, :string
    field :status, Ecto.Enum, values: [:pending, :in_progress, :completed, :failed, :skipped]
    field :processor, :atom
    field :dependencies, {:array, :string}, default: []
    field :result, :map
    field :error, :string
  end
end

# lib/agent_framework/tools/behaviour.ex
defmodule AgentFramework.Tool do
  @callback execute(struct()) :: {:ok, term()} | {:error, term()}

  defmacro __using__(_opts) do
    quote do
      @behaviour AgentFramework.Tool
      use Ecto.Schema
      import Ecto.Changeset

      Module.register_attribute(__MODULE__, :tool_description, persist: true)
      Module.register_attribute(__MODULE__, :field_descriptions, persist: true)

      @after_compile AgentFramework.Tools.Registry
    end
  end
end

# lib/agent_framework/llm/behaviour.ex
defmodule AgentFramework.LLM.Provider do
  @type message :: %{role: String.t(), content: String.t()}
  @type tool_schema :: map()
  @type options :: keyword()
  @type chunk :: String.t()
  @type stream_callback :: (chunk() -> :ok)

  @callback chat(messages :: [message()], opts :: options()) ::
    {:ok, String.t()} | {:error, term()}

  @callback chat_with_tools(messages :: [message()], tools :: [tool_schema()], opts :: options()) ::
    {:ok, %{content: String.t(), tool_calls: [map()]}} | {:error, term()}

  @callback stream(messages :: [message()], callback :: stream_callback(), opts :: options()) ::
    {:ok, String.t()} | {:error, term()}
end

# lib/agent_framework/session/controller.ex
defmodule AgentFramework.Session.Controller do
  use GenServer

  @type state :: %{
    session: AgentFramework.Schemas.Session.t(),
    subscribers: [pid()]
  }

  # Pattern matching for state transitions
  def handle_info({:step_complete, step_id, result}, %{session: session} = state) do
    session = update_step(session, step_id, result)

    case next_action(session) do
      {:continue, next_step} ->
        enqueue_step(next_step)
        {:noreply, %{state | session: session}}

      {:done, final_result} ->
        notify_subscribers(state.subscribers, {:session_complete, final_result})
        {:stop, :normal, state}

      {:error, reason} ->
        {:stop, {:error, reason}, state}
    end
  end
end
```

### Implementation Order

1. **Foundation**
   - `state/tables.ex` - ETS table creation
   - `schemas/*.ex` - All Ecto embedded schemas
   - `state/persistence_worker.ex` - Write-behind to Postgres

2. **Session Management**
   - `session/controller.ex` - Core state machine
   - `session/supervisor.ex` - DynamicSupervisor
   - `session/registry.ex` - Process lookup

3. **Pipeline**
   - `pipeline/producer.ex` - GenStage with :queue
   - `pipeline/broadway.ex` - Broadway config
   - `pipeline/processors/*.ex` - Sub-agents (start with one)

4. **Tools**
   - `tools/behaviour.ex` - Tool protocol
   - `tools/registry.ex` - Registration
   - `tools/executor.ex` - Task-based execution
   - `tools/schema.ex` - JSON schema generation

5. **LLM Integration**
   - `llm/behaviour.ex` - Provider protocol
   - `llm/providers/openai.ex` - First provider
   - `llm/streaming.ex` - Req + PubSub
   - `llm/rate_limiter.ex` - Hammer

6. **Memory & Context**
   - `memory/token_counter.ex` - Tiktoken
   - `memory/context_builder.ex` - Prompt assembly
   - `memory/eviction.ex` - Budget enforcement

7. **Clustering**
   - `state/hash_ring.ex` - ex_hash_ring integration
   - `session/router.ex` - Cross-node routing
   - Failover testing

8. **Observability & Hardening**
   - `telemetry/*.ex` - Telemetry events
   - `recovery/*.ex` - Checkpoint recovery
   - Integration tests

---

**Consolidated design document**: `docs/elixir-design.md`

---

## Appendix: LangGraph Alignment Analysis

### Strong Alignment (Same Concepts)
- **Shared state** - ETS tables serve same role as LangGraph's StateGraph
- **Reducers** - Ecto changesets provide controlled updates like LangGraph's Annotated reducers
- **Conditional routing** - Pattern matching in `next_action/1` mirrors conditional edges
- **Checkpointing** - Postgres write-behind achieves same recovery capability

### Intentional Divergence (Elixir Idioms)
- **No explicit graph** - We use Broadway pipeline + SessionController instead of declarative graph DSL
- **No compiled graph** - Dynamic dispatch via GenServer, not pre-compiled structure
- **Tables vs channels** - Coarser ETS tables instead of per-field channels

### Decision
**Keep current design.** Functional alignment is sufficient. We achieve LangGraph's outcomes through Elixir-native patterns. The divergence is stylistic, not capability-limiting.

Key insight: LangGraph is a graph library that does agents. We're building an agent framework using Elixir's native constructs (OTP, Broadway, ETS). Same destination, different vehicles.

---

## Additional Dimensions (Added Post-Review)

### Dimension 11: Interrupts/Breakpoints

**Discussion:**
- LangGraph provides `interrupt_before`/`interrupt_after` for pausing execution
- Needed for: approval gates, debugging, cost control, human review

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Configuration | Hybrid: step-level schema + runtime breakpoint registry |
| Behavior | Timeout with configurable default (block N seconds, then auto-action) |
| Resume | `AgentFramework.Session.resume(session_id, opts)` |
| Notification | PubSub broadcast to subscribers on interrupt |

**Schema additions:**
```elixir
# In Step schema
field :interrupt, Ecto.Enum, values: [:none, :before, :after], default: :none
field :interrupt_timeout_ms, :integer, default: 300_000  # 5 min
field :interrupt_default_action, Ecto.Enum, values: [:continue, :fail], default: :fail
```

**Runtime API:**
```elixir
AgentFramework.Breakpoints.set(session_id, :before, :code_execute)
AgentFramework.Breakpoints.clear(session_id)
```

---

### Dimension 12: Human-in-the-Loop (HITL)

**Discussion:**
- Distinct from interrupts: agent explicitly requests human input as part of workflow
- Use cases: approval, clarification, correction, guidance

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Implementation | Hybrid: `:human_input` step type + `AskHuman` tool |
| Delivery | PubSub → Phoenix Channel → WebSocket |
| Response | `Session.provide_input(session_id, step_id, input)` |
| Timeout | Configurable per step/tool call, default action on timeout |

**Architecture:**
```
Frontend (WebSocket) ←→ Phoenix Channel ←→ PubSub ←→ SessionController
```

**Step type for planned HITL:**
```elixir
%Step{
  type: :human_input,
  description: "Review research and provide feedback",
  input_schema: %{feedback: :string, approved: :boolean},
  timeout_ms: 600_000
}
```

**Tool for emergent HITL:**
```elixir
defmodule AgentFramework.Tools.AskHuman do
  use AgentFramework.Tool
  @tool_description "Ask the human user for input or clarification"
  # LLM can call this when it needs help
end
```

---

### Dimension 13: Time Travel Debugging

**Discussion:**
- Tracing (Dim 9) = "What happened?" (observability)
- Time Travel = "What was the state at point X?" (inspection)
- L1 (view-only) sufficient for production debugging, auditing, training data

**Decisions:**

| Aspect | Choice |
|--------|--------|
| Snapshot strategy | Hybrid: full snapshot every N steps + events between |
| Replay level | L1: View-only (inspect historical state, no re-execution) |
| Storage | Postgres (checkpoints table, events table) |
| Query API | `TimeTravel.state_at(session_id, step_index)` |

**Event schema:**
```elixir
defmodule AgentFramework.Schemas.Event do
  embedded_schema do
    field :session_id, :binary_id
    field :step_index, :integer
    field :sequence, :integer
    field :timestamp, :utc_datetime_usec
    field :type, Ecto.Enum, values: [
      :step_started, :step_completed, :step_failed,
      :llm_request, :llm_response,
      :tool_called, :tool_result,
      :interrupt_triggered, :interrupt_resumed,
      :hitl_requested, :hitl_received
    ]
    field :data, :map
  end
end
```

**Query API:**
```elixir
TimeTravel.state_at(session_id, step_index)      # Reconstructed state
TimeTravel.events_for_step(session_id, step_index)  # Events in step
TimeTravel.full_timeline(session_id)              # All events ordered
```

---

## Updated Session Summary

**All 13 dimensions decided:**
1. Core Architecture: Deep Agents pattern via Broadway pipeline
2. Process Structure: Broadway + GenStage producer with :queue
3. State Model: PostgreSQL + Redis with Ecto embedded schemas
4. Message Protocol + Distribution: Reference structs, 4 ETS tables, ex_hash_ring, write-behind
5. Tool System: Ecto schemas, introspection, @tool_description, Task isolation
6. LLM Integration: Req + Behaviour adapters, streaming via PubSub, Hammer rate limiting, :fuse circuit breaker
7. Memory/Context: Token budget + eviction, pgvector + pg_bm25, tiktoken NIF
8. Multi-Agent Coordination: SessionController GenServer + Broadway execution pipeline
9. Observability: Telemetry + OpenTelemetry, step-level granularity
10. Error Handling: Feed errors to LLM, checkpoint recovery, configurable max iterations
11. Interrupts/Breakpoints: Hybrid (step-level + runtime registry), timeout with default action
12. Human-in-the-Loop: Step type + tool, PubSub → Phoenix Channel → WebSocket
13. Time Travel Debugging: Hybrid snapshots + events, L1 view-only inspection
